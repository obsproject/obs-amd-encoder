Utility.Default="默认"
Utility.Automatic="自动"
Utility.Manual="手动"
Utility.Switch.Disabled="禁用"
Utility.Switch.Enabled="启用"
Preset="预设"
Preset.ResetToDefaults="重置为默认值"
Preset.Recording="录像"
Preset.HighQuality="高质量"
Preset.Indistinguishable="无法区分"
Preset.Lossless="无损"
Preset.Twitch="Twitch"
Preset.YouTube="YouTube"
Usage="使用"
Usage.Description="AMF 应调整为什么用法:\n-'\@Usage.Transcoding\@' 是通用转码(推荐),\n- '\@Usage.UltraLowLatency\@' 用于真正低延迟编码,\n-'\@Usage.LowLatency\@' 类似于上面稍高的延迟.\n 推流仅支持 '\@Usage.Transcoding\@', 所有其他值可以用于录制."
Usage.Transcoding="转码"
Usage.UltraLowLatency="超低延迟"
Usage.LowLatency="低延迟"
Usage.Webcam="网络摄像头"
QualityPreset="质量预设"
QualityPreset.Description="质量预设 AMF 应尝试向目标:\n-'\@QualityPreset.Speed\@' 是最快但最差的质量,\n-'\@QualityPreset.Balanced\@' 是平衡两者的混合,\n-'\@QualityPreset.Quality\@' 给出了最好的质量为给定的比特率."
QualityPreset.Speed="速度"
QualityPreset.Balanced="平衡"
QualityPreset.Quality="质量"
Profile="配置文件"
Profile.Description="什么配置文件进行编码. 从最佳支持(顶部) 到最好的质量(底部) 排序."
ProfileLevel="配置等级"
ProfileLevel.Description="要使用哪些配置文件级别. 最好设置在 \@Utility.Automatic\@."
Tier="层"
Tier.Description="要在编码在哪一层. '高' 目标高的比特率/带宽使用, 而 '主' 针对主流媒体."
AspectRatio="长宽比"
AspectRatio.Description="哪个长宽比应写入输出文件."
CodingType="编码类型"
CodingType.Description="使用哪种编码类型:\n* '\@Utility.Automatic\@' 让 AMF 决定(推荐).\n* 'CALVC'(上下文自适应可变长度编码) 速度更快但是更大.\n* 'CABAC'(上下文自适应二进制算术编码)速度更慢, 但是更小."
MaximumReferenceFrames="最大参考帧"
MaximumReferenceFrames.Description="在大多数编码时多少帧编码器可能会引用, 对编码质量有直接影响."
RateControlMethod="速率控制方法"
RateControlMethod.Description="应该使用什么比率控制方法:\n- '\@RateControlMethod.CQP\@' 赋值固定的 I/P/B 帧 QP(量化参数) 值,\n- '\@RateControlMethod.CBR\@' 保持在一个给定的目标比特率(使用过滤数据)(推荐用于推流),\n- '\@RateControlMethod.VBR\@' 保持在给定的峰值比特率以下,\n- '\@RateControlMethod.VBRLAT\@' 保持接近目标比特率如果 GPU 延迟和负载, 否则将会使用更高的比特率(推荐用于录制)."
RateControlMethod.CQP="恒定 QP (CQP)"
RateControlMethod.CBR="固定比特率 (CBR)"
RateControlMethod.VBR="变比特率 (峰值约束) (VBR)"
RateControlMethod.VBRLAT="变比特率 (延迟约束) (VBR_LAT)"
PrePassMode="前通模式"
PrePassMode.Description="前通是次选的比特率发行通过, 允许更好发行在一个序列内的比特率, 然而效果可能会随着不同的卡而不同."
PrePassMode.Quarter="\@Utility.Switch.Enabled\@ (四分之一大小)"
PrePassMode.Half="\@Utility.Switch.Enabled\@ (半尺寸)"
PrePassMode.Full="\@Utility.Switch.Enabled\@ (全尺寸)"
Bitrate.Target="目标比特率"
Bitrate.Target.Description="尝试在整个序列中获取的比特率."
Bitrate.Peak="峰值比特率"
Bitrate.Peak.Description="尝试在整个序列中最大获取的比特率."
QP.IFrame="I 帧 QP"
QP.IFrame.Description="用于 I 帧的固定的 QP 值."
QP.PFrame="P 帧 QP"
QP.PFrame.Description="用于 P 帧的固定 QP 值."
QP.BFrame="B 帧 QP"
QP.BFrame.Description="用于 B 帧的固定的 QP 值."
QP.Minimum="最低 QP"
QP.Minimum.Description="在一个 I 帧中使用的最低 QP 值."
QP.IFrame.Minimum="最小 I-帧 QP"
QP.IFrame.Minimum.Description="在一个 I 帧中使用的最低 QP 值."
QP.PFrame.Minimum="最小 I-帧 QP"
QP.PFrame.Minimum.Description="在一个 P 帧中使用的最低 QP 值."
QP.Maximum="最高 QP"
QP.Maximum.Description="在一个帧中使用的最高 QP 值."
QP.IFrame.Maximum="最大 I-帧 QP"
QP.IFrame.Maximum.Description="在一个 I 帧中使用的最高 QP 值."
QP.PFrame.Maximum="最大的 P 帧 QP"
QP.PFrame.Maximum.Description="在一个 P 帧中使用的最高 QP 值."
FillerData="填充数据"
FillerData.Description="启用填充数据允许编码器至少保持 \@Bitrate.Target\@, 通过填满空信息序列中的剩余空间."
FrameSkipping="跳过的帧"
FrameSkipping.Description="跳过的帧允许编码器下丢帧, 以满足\@Bitrate.Target\@ 要求.\n当编码器丢帧时, 它反而插入一个重复最后一帧的 NAL 到流中.\n可以帮助非常低的\@Bitrate.Target\@."
FrameSkipping.Period="跳过帧周期"
FrameSkipping.Period.Description="跳过帧之间的间隔(以帧). 这个用来仿真比 OBS 设置的低的帧率同时仍然有一个合法的流."
FrameSkipping.Behaviour="跳帧行为"
FrameSkipping.Behaviour.Description="定义跳帧的处理方式."
FrameSkipping.SkipNth="跳过每第 N 帧"
FrameSkipping.KeepNth="保持每第 N 帧"
VBAQ="VBAQ"
VBAQ.Description="启用'基于方差的自适应量化'(VBAQ), 基于像素的方差来更好地区分比特率.\n他基于原理人类的视觉系统是对高纹理的物体不敏感, 因而将推动比特率来实现更平滑的界面.\n启用这个可能会导致某些内容的主观质量的改善."
EnforceHRD="强制 HRD"
EnforceHRD.Description="强制使用假设的参考解码器, 用于验证输出码流是否正确."
VBVBuffer="VBV 缓存"
VBVBuffer.Description="应使用什么方法来确定 VBV 缓冲区大小:\n-'\@Utlity.Automatic\@' 计算使用严格约束的大小,\n- '\@Utlity.Manual\@' 允许用户控制大小.\nVBV缓存 (视频缓冲程序验证程序) 用于某些率控制方法来保持整体的比特率在给定的约束内."
VBVBuffer.Strictness="VBV 缓存规范性"
VBVBuffer.Strictness.Description="决定 VBV 缓存的严格性, 100% 表示尽可能严格, 0% 表示无限制."
VBVBuffer.Size="VBV 缓存大小"
VBVBuffer.Size.Description="用于在一个序列中的控制比特率的 VBV 缓存的大小."
VBVBuffer.InitialFullness="VBV 缓冲区初始满"
VBVBuffer.InitialFullness.Description="VBV 缓存最初应该多满(百分比), 将只会影响最初的序列的编码."
Interval.Keyframe="关键帧间隔"
Interval.Keyframe.Description="关键帧之间间隔(以秒为单位)."
Period.IDR.H264="IDR 周期 (以帧)"
Period.IDR.H264.Description="定义瞬时解码刷新 (IDR) 的距离以帧为单位."
Period.IDR.H265="IDR 周期 (以 GOP 为单位)"
Period.IDR.H265.Description="定义瞬时解码刷新 (IDR) 的距离以 GOP 为单位."
Interval.IFrame="关键帧间隔"
Interval.IFrame.Description="I 帧间隔 (以秒为单位). I 帧覆盖 P 帧和 B 帧."
Period.IFrame="关键帧周期 (以帧)"
Period.IFrame.Description="I 帧间隔 (以帧为单位). I 帧覆盖 P 帧和 B 帧."
Interval.PFrame="P 帧间隔"
Interval.PFrame.Description="P 帧间隔 (以秒为单位). P 帧覆盖 B 帧."
Period.PFrame="P 帧周期 (以帧为单位)"
Period.PFrame.Description="P 帧之间距离 (以帧为单位). P 帧覆盖 B 帧."
Interval.BFrame="B 帧间隔"
Interval.BFrame.Description="B 帧之间间隔(以秒为单位)."
Period.BFrame="B 帧间隔(以帧)"
Period.BFrame.Description="B 帧直接的距离(以帧)."
GOP.Type="GOP 类型"
GOP.Type.Description="应使用哪种类型的 GOP:\n-'\@GOP.Type.Fixed\@' 将始终使用固定的每个 GOP 之间的距离之.\n-'\@GOP.Type.Variable\@' 允许 GOPs 为不同值, 取决于什么是需要的.\n'\@GOP.Type.Fixed\@' 是 H264 实现如何工作和最好的本地网络推流, 而 '\@GOP.Type.Variable\@' 是最适合低大小高品质的录像."
GOP.Type.Fixed="固定的"
GOP.Type.Variable="可变的"
GOP.Size="GOP 大小"
GOP.Size.Description="帧中最大的 GOP (Group Of Pictures) 大小"
GOP.Size.Minimum="GOP 大小最小值"
GOP.Size.Minimum.Description="帧中最小的 GOP (Group Of Pictures) 大小"
GOP.Size.Maximum="GOP 大小最大值"
GOP.Size.Maximum.Description="帧中最大的 GOP (Group Of Pictures) 大小"
GOP.Alignment="GOP 对齐"
GOP.Alignment.Description="实验, 效果是未知. 使用风险由自己负责."
BFrame.Pattern="B 帧模式"
BFrame.Pattern.Description="在编码时使用多少 B 帧.\n2 代和 3 代 VCE 卡支持. 对编码性能有负面影响."
BFrame.DeltaQP="B 帧差值 QP"
BFrame.DeltaQP.Description="对于非参考 B 帧, 相对于上一个 I 或者 P 帧的差值 QP 值."
BFrame.Reference="B 帧参考"
BFrame.Reference.Description="允许 B 帧也使用 B 帧作为参考, 而不是只是 P 和 I 帧."
BFrame.ReferenceDeltaQP="B 帧参考差值 QP"
BFrame.ReferenceDeltaQP.Description="对于参考 B 帧, 相对于上一个 I 或者 P 帧的差值 QP 值."
DeblockingFilter="去块滤波"
DeblockingFilter.Description="允许解码器申请去块滤波器."
MotionEstimation="移动侦测"
MotionEstimation.Description="运动侦测允许编码器通过预测一个像素去了哪里来降低需要的比特率."
MotionEstimation.Quarter="四分之一像素"
MotionEstimation.Half="半像素"
MotionEstimation.Full="四分之一 & 半像素"
Video.API="视频的 API"
Video.API.Description="后端应使用什么 API?"
Video.Adapter="视频适配器"
Video.Adapter.Description="我们应该尝试在什么适配器上编码?"
OpenCL.Transfer="OpenCL 转移"
OpenCL.Transfer.Description="使用 OpenCL 来传输帧而不是映射内存. 当 GPU 被使用时, 通过 OpenCL 转移相比通过映射内存传输更少分散."
OpenCL.Conversion="OpenCL 转换"
OpenCL.Conversion.Description="使用 OpenCL 转换在 GPU 上的帧而不是 DirectCompute."
MultiThreading="多线程"
MultiThreading.Description="使用多个线程来处理提交帧和检索数据包. 这有助于在较慢的 CPU 上, 但将为整体的系统资源使用. 它将对更快的 CPU 的性能产生负面影响."
QueueSize="队列大小"
QueueSize.Description="在尝试检索数据包之前, 为编码器查询这些多个帧. 较高的值引入更多的延迟, 同时较低的值可能会导致超载编码. 不推荐更改此默认值."
View="查看模式"
View.Description="应显示哪些属性?\n使用 '\@View.Master\@' 会使你丧失获得技术支持的资格."
View.Basic="基本"
View.Advanced="高级"
View.Expert="专家"
View.Master="主"
Debug="调试"
Debug.Description="启用额外的调试消息. 需要你用 '--verbose --log_unfiltered'(删掉') 命令行运行打开OBS。"
AMF.H264.MaximumLTRFrames="最大的 LTR 帧"
AMF.H264.MaximumLTRFrames.Description="长期参考帧(LTR) 是一个特性允许编码器来标记在一个序列的一些帧作为参考帧一段时间.\nLTR 帧不能和 B 帧一起使用并且如果使用 LTR 帧, 编码器会禁用 B 帧."
AMF.H264.MaximumAccessUnitSize="最大访问单元大小"
AMF.H264.MaximumAccessUnitSize.Description="一个 NAL 的访问单元的最大大小. 值 0 允许编码器挑选最好的一个."
AMF.H264.HeaderInsertionSpacing="头部插入空白"
AMF.H264.HeaderInsertionSpacing.Description="NAL 头之间应该多少帧. 不推荐改为非零(自动) 值."
AMF.H264.WaitForTask="等待任务"
AMF.H264.WaitForTask.Description="未知, 实验"
AMF.H264.SlicesPerFrame="每帧的切片数"
AMF.H264.SlicesPerFrame.Description="每个帧应该和多少 I 帧切片一起存储?\n0 值让编码器运行时决定.\n内部刷新编码用于更快的回放和定位."
AMF.H264.SliceMode="切片模式"
AMF.H264.SliceMode.Description="未知, 实验"
AMF.H264.MaximumSliceSize="最大切片大小"
AMF.H264.MaximumSliceSize.Description="未知, 实验"
AMF.H264.SliceControlMode="切片控制模式"
AMF.H264.SliceControlMode.Description="未知, 实验"
AMF.H264.SliceControlSize="切片控制大小"
AMF.H264.SliceControlSize.Description="未知, 实验"
AMF.H264.IntraRefresh.NumberOfStripes="帧内刷新的条纹的数目"
AMF.H264.IntraRefresh.NumberOfStripes.Description="未知, 实验"
AMF.H264.IntraRefresh.MacroblocksPerSlot="每个插槽的帧内刷新宏"
AMF.H264.IntraRefresh.MacroblocksPerSlot.Description="每个槽应该和多少宏块一起存储?\n0 值让编码器在运行时决定.\n帧内刷新编码用于更快的回放和定位."

